package org.owasp.codespy;

import java.util.Vector;
import org.owasp.codespy.Rule;
import org.owasp.codespy.Reference;
import org.owasp.codespy.Result;
import org.owasp.codespy.Severity;
import org.owasp.codespy.ClassProxy;

/** 
 * An abstract class which implements the {@link Rule} interface to perform a
 * rule based evaluation of a class. The actual evaluation (implementation) of
 * the rule is performed by the extending class.
 * @author Mark Curphey
 * @version 1.0
 */
public abstract class AtomicRule 
	implements Rule 
{
	private Reference reference; // additional information
	private Vector results; // evaluation result set
	private Severity severity; // severity level of results
	
	/** 
	 * Constructs a rule with the specified reference and suggestion.
	 * @param reference provides additional information about the rule.
	 * @param severity indicates severity level of results.
	 */
	public AtomicRule ( Reference reference, Severity severity ) {
		this.reference = reference;
		this.severity = severity;
		results = new Vector();
	}

	/** 
	 * Returns the reference registered for this rule.
	 * @return the reference registered for this rule.
	 */
	public final Reference getReference () {
		return reference;
	}

	/** 
	 * Returns the severity registered for this rule.
	 * @return the severity registered for this rule.
	 */
	public final Severity getSeverity () {
		return severity;
	}

	/** 
	 * Indicates if the rule has produced results.
	 * @return <code>true</code> if the rule has produced results. Otherwise
	 * <code>false</code> if the rule did not produce results, has not yet
	 * been evaluated, or the results have been cleared.
	 */
	public final boolean hasResults () {
		return results.size() == 0
		         ? false
		         : true;
	}

	/** 
	 * Returns the result set of the rule applied to the target class. Any
	 * results from a previous evaluation are discarded prior to the current
	 * evaluation.
	 * @param target the class the rule is applied to.
	 * @return the result set (possibly empty) of the rule applied to the
	 * target class.
	 */
	public final Result[] evaluate ( ClassProxy target ) {
		results.removeAllElements(); // clear the result cache
		test( target );
		return getResults();
	}

	/** 
	 * Returns a string representation of this object. If a reference is
	 * is registered for this rule, then the text of that reference is
	 * returned (presumably, a plain text description of the rule).
	 * Otherwise, this method defers to {@link java.lang.Object#toString}.
	 * @return a string representation of this object.
	 */
	public String toString () {
		if ( reference == null )
			return super.toString(); // provide something
			 else
			return reference.getText();
	}

	/** 
	 * Produces the result set of the rule applied to the target class. The
	 * implementing class is free to implement any type of rule and to
	 * register any number of results. The implementation should limit itself
	 * to a single, stand-alone rule.
	 * @param target the class the rule is applied to.
	 */
	protected abstract void test ( ClassProxy target );

	/** 
	 * Returns the results generated by evaluation.
	 * @return the results generated by evaluation.
	 */
	protected final synchronized Result[] getResults () {
		return (Result[]) results.toArray( new Result[results.size()] );
	}

	/** 
	 * Add to the result set for the evaluation. During evaluation, the
	 * rule may produce one or more results. An extending class uses this
	 * method to register those results it produces.
	 * @param result the result to be added.
	 */
	protected final synchronized void addResult ( Result result ) {
		results.addElement( result );
	}

	/** 
	 * Loads the named class into the virtual machine if it has not been
	 * loaded previously.
	 * @param name the fully qualified name of the class to load.
	 * @throws ClassNotFoundException if the class loader cannot find the
	 * class.
	 * @throws NoClassDefFoundError if the virtual machine is unable to
	 * resolve the class.
	 */
	protected final void loadClass ( String name )
		throws ClassNotFoundException, NoClassDefFoundError
	{
		Class.forName( name );
	}
}

