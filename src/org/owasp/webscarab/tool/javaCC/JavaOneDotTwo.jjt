/**
  *
  * This file contains a Java grammar for Java 1.2 compliant source files.
  * It is used to build up a code formatter for *.java source files.
  *
  */

options {
  JAVA_UNICODE_ESCAPE = true;

  STATIC=false;
  MULTI=true;
  VISITOR=true;
  NODE_USES_PARSER=true;
  NODE_PREFIX="Node";
}

PARSER_BEGIN( JavaOneDotTwo )

package org.owasp.webscarab.tool.javaCC;

public class JavaOneDotTwo {
}

PARSER_END( JavaOneDotTwo )

/* WHITE SPACE */

SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
| "\f"
}

/* COMMENTS */

MORE :
{
  "//" : IN_SINGLE_LINE_COMMENT
|
  <"/**" ~["/"]> { input_stream.backup(1); } : IN_FORMAL_COMMENT
|
  "/*" : IN_MULTI_LINE_COMMENT
}

<IN_SINGLE_LINE_COMMENT>
SPECIAL_TOKEN :
{
  <SINGLE_LINE_COMMENT: "\n" | "\r" | "\r\n" > : DEFAULT
}

<IN_FORMAL_COMMENT>
SPECIAL_TOKEN :
{
  <FORMAL_COMMENT: "*/" > : DEFAULT
}

<IN_MULTI_LINE_COMMENT>
SPECIAL_TOKEN :
{
  <MULTI_LINE_COMMENT: "*/" > : DEFAULT
}

<IN_SINGLE_LINE_COMMENT,IN_FORMAL_COMMENT,IN_MULTI_LINE_COMMENT>
MORE :
{
  < ~[] >
}

/* RESERVED WORDS AND LITERALS */

TOKEN :
{
  < ABSTRACT: "abstract" >
| < BOOLEAN: "boolean" >
| < BREAK: "break" >
| < BYTE: "byte" >
| < CASE: "case" >
| < CATCH: "catch" >
| < CHAR: "char" >
| < CLASS: "class" >
| < CONST: "const" >
| < CONTINUE: "continue" >
| < _DEFAULT: "default" >
| < DO: "do" >
| < DOUBLE: "double" >
| < ELSE: "else" >
| < EXTENDS: "extends" >
| < FALSE: "false" >
| < FINAL: "final" >
| < FINALLY: "finally" >
| < FLOAT: "float" >
| < FOR: "for" >
| < GOTO: "goto" >
| < IF: "if" >
| < IMPLEMENTS: "implements" >
| < IMPORT: "import" >
| < INSTANCEOF: "instanceof" >
| < INT: "int" >
| < INTERFACE: "interface" >
| < LONG: "long" >
| < NATIVE: "native" >
| < NEW: "new" >
| < NULL: "null" >
| < PACKAGE: "package">
| < PRIVATE: "private" >
| < PROTECTED: "protected" >
| < PUBLIC: "public" >
| < RETURN: "return" >
| < SHORT: "short" >
| < STATIC: "static" >
| < SUPER: "super" >
| < SWITCH: "switch" >
| < SYNCHRONIZED: "synchronized" >
| < THIS: "this" >
| < THROW: "throw" >
| < THROWS: "throws" >
| < TRANSIENT: "transient" >
| < TRUE: "true" >
| < TRY: "try" >
| < VOID: "void" >
| < VOLATILE: "volatile" >
| < WHILE: "while" >
| < STRICTFP: "strictfp" >
}

/* LITERALS */

TOKEN :
{
  < INTEGER_LITERAL:
  <DECIMAL_LITERAL> (["l","L"])?
  | <HEX_LITERAL> (["l","L"])?
  | <OCTAL_LITERAL> (["l","L"])?
  >
|
  < #DECIMAL_LITERAL: ["1"-"9"] (["0"-"9"])* >
|
  < #HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+ >
|
  < #OCTAL_LITERAL: "0" (["0"-"7"])* >
|
  < FLOATING_POINT_LITERAL:
  (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)? (["f","F","d","D"])?
  | "." (["0"-"9"])+ (<EXPONENT>)? (["f","F","d","D"])?
  | (["0"-"9"])+ <EXPONENT> (["f","F","d","D"])?
  | (["0"-"9"])+ (<EXPONENT>)? ["f","F","d","D"]
  >
|
  < #EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
|
  < CHARACTER_LITERAL:
  "'"
  ( (~["'","\\","\n","\r"])
  | ("\\"
  ( ["n","t","b","r","f","\\","'","\""]
  | ["0"-"7"] ( ["0"-"7"] )?
  | ["0"-"3"] ["0"-"7"] ["0"-"7"]
  )
  )
  )
  "'"
  >
|
  < STRING_LITERAL:
  "\""
  ( (~["\"","\\","\n","\r"])
  | ("\\"
  ( ["n","t","b","r","f","\\","'","\""]
  | ["0"-"7"] ( ["0"-"7"] )?
  | ["0"-"3"] ["0"-"7"] ["0"-"7"]
  )
  )
  )*
  "\""
  >
}

/* IDENTIFIERS */

TOKEN :
{
  < IDENTIFIER: <LETTER> (<LETTER>|<DIGIT>)* >
|
  < #LETTER:
  [
  "\u0024",
  "\u0041"-"\u005a",
  "\u005f",
  "\u0061"-"\u007a",
  "\u00c0"-"\u00d6",
  "\u00d8"-"\u00f6",
  "\u00f8"-"\u00ff",
  "\u0100"-"\u1fff",
  "\u3040"-"\u318f",
  "\u3300"-"\u337f",
  "\u3400"-"\u3d2d",
  "\u4e00"-"\u9fff",
  "\uf900"-"\ufaff"
  ]
  >
|
  < #DIGIT:
  [
  "\u0030"-"\u0039",
  "\u0660"-"\u0669",
  "\u06f0"-"\u06f9",
  "\u0966"-"\u096f",
  "\u09e6"-"\u09ef",
  "\u0a66"-"\u0a6f",
  "\u0ae6"-"\u0aef",
  "\u0b66"-"\u0b6f",
  "\u0be7"-"\u0bef",
  "\u0c66"-"\u0c6f",
  "\u0ce6"-"\u0cef",
  "\u0d66"-"\u0d6f",
  "\u0e50"-"\u0e59",
  "\u0ed0"-"\u0ed9",
  "\u1040"-"\u1049"
  ]
  >
}

/* SEPARATORS */

TOKEN :
{
  < LPAREN: "(" >
| < RPAREN: ")" >
| < LBRACE: "{" >
| < RBRACE: "}" >
| < LBRACKET: "[" >
| < RBRACKET: "]" >
| < SEMICOLON: ";" >
| < COMMA: "," >
| < DOT: "." >
}

/* OPERATORS */

TOKEN :
{
  < ASSIGN: "=" >
| < GT: ">" >
| < LT: "<" >
| < BANG: "!" >
| < TILDE: "~" >
| < HOOK: "?" >
| < COLON: ":" >
| < EQ: "==" >
| < LE: "<=" >
| < GE: ">=" >
| < NE: "!=" >
| < SC_OR: "||" >
| < SC_AND: "&&" >
| < INCR: "++" >
| < DECR: "--" >
| < PLUS: "+" >
| < MINUS: "-" >
| < STAR: "*" >
| < SLASH: "/" >
| < BIT_AND: "&" >
| < BIT_OR: "|" >
| < XOR: "^" >
| < REM: "%" >
| < LSHIFT: "<<" >
| < RSIGNEDSHIFT: ">>" >
| < RUNSIGNEDSHIFT: ">>>" >
| < PLUSASSIGN: "+=" >
| < MINUSASSIGN: "-=" >
| < STARASSIGN: "*=" >
| < SLASHASSIGN: "/=" >
| < ANDASSIGN: "&=" >
| < ORASSIGN: "|=" >
| < XORASSIGN: "^=" >
| < REMASSIGN: "%=" >
| < LSHIFTASSIGN: "<<=" >
| < RSIGNEDSHIFTASSIGN: ">>=" >
| < RUNSIGNEDSHIFTASSIGN: ">>>=" >
}


/*****************************************
  * THE JAVA LANGUAGE GRAMMAR STARTS HERE *
  *****************************************/

/*
 * Program structuring syntax follows.
 */

NodeCompilationUnit CompilationUnit() :
{}
{
  [ PackageDeclaration() ]
  ( ImportDeclaration() )*
  ( TypeDeclaration() )*
  <EOF>
  {
     return jjtThis;
  }  
}

void PackageDeclaration() :
{}
{
  KT_PACKAGE() Name() ST_SEMICOLON()
}

void ImportDeclaration() :
{}
{
  KT_IMPORT() Name() [ ST_DOT() OT_STAR() ] ST_SEMICOLON()
}

void TypeDeclaration() :
{}
{
  LOOKAHEAD( ( KT_PUBLIC() | ( KT_FINAL() | KT_ABSTRACT() ) | KT_STRICTFP() )* KT_CLASS() )
  ClassDeclaration()
|
  InterfaceDeclaration()
|
  ST_SEMICOLON()
}


/*
 * Declaration syntax follows.
 */

void ClassDeclaration() :
{}
{
  ( KT_PUBLIC() | ( KT_FINAL() | KT_ABSTRACT() ) | KT_STRICTFP() )* #Modifiers(true) 
  UnmodifiedClassDeclaration()
}

void UnmodifiedClassDeclaration() :
{}
{
  KT_CLASS() RT_IDENTIFIER() [ KT_EXTENDS() Name() ] [ KT_IMPLEMENTS() NameList() ]
  ClassBody()
}

void ClassBody() :
{}
{
  ST_LBRACE() ( ClassBodyDeclaration() )* ST_RBRACE()
}

void NestedClassDeclaration() :
{}
{

  (   KT_PUBLIC() | KT_PROTECTED() | KT_PRIVATE() 
    | KT_ABSTRACT() | KT_FINAL()
    | KT_STRICTFP()
    | KT_STATIC() )* #Modifiers(true)
  UnmodifiedClassDeclaration()
}

void ClassBodyDeclaration() :
{}
{
  LOOKAHEAD(2)
  Initializer()
|
  LOOKAHEAD( ( KT_PUBLIC() | KT_PROTECTED() | KT_PRIVATE() | KT_ABSTRACT() | KT_FINAL()  | KT_STRICTFP() | KT_STATIC() )* KT_CLASS() )
  NestedClassDeclaration()
|
  LOOKAHEAD( ( KT_PUBLIC() | KT_PROTECTED() | KT_PRIVATE() | KT_ABSTRACT() | KT_FINAL()  | KT_STRICTFP() | KT_STATIC() )* KT_INTERFACE() )
  NestedInterfaceDeclaration()
|
  LOOKAHEAD( [ KT_PUBLIC() | KT_PROTECTED() | KT_PRIVATE() ] Name() ST_LPAREN() )
  ConstructorDeclaration()
|
  LOOKAHEAD( MethodDeclarationLookahead() )
  MethodDeclaration()
|
  FieldDeclaration()
}

// This production is to determine lookahead only.
void MethodDeclarationLookahead() :
{}
{
  (   KT_PUBLIC() | KT_PROTECTED() | KT_PRIVATE() 
    | KT_STATIC() | KT_ABSTRACT() | KT_FINAL() 
    | KT_NATIVE() | KT_SYNCHRONIZED() | KT_STRICTFP() )* #Modifiers(true)
  ResultType() RT_IDENTIFIER() ST_LPAREN()
}

void InterfaceDeclaration() :
{}
{
  ( KT_ABSTRACT() | KT_PUBLIC() | KT_STRICTFP() )* #Modifiers(true)
  UnmodifiedInterfaceDeclaration()
}

void NestedInterfaceDeclaration() :
{}
{
  (   KT_PUBLIC() | KT_PROTECTED() | KT_PRIVATE() 
    | KT_ABSTRACT() | KT_FINAL()
    | KT_STRICTFP()
    | KT_STATIC() )* #Modifiers(true)
  UnmodifiedInterfaceDeclaration()
}

void UnmodifiedInterfaceDeclaration() :
{}
{
  KT_INTERFACE() RT_IDENTIFIER() [ KT_EXTENDS() NameList() ]
  ST_LBRACE() ( InterfaceMemberDeclaration() )* ST_RBRACE()
}

void InterfaceMemberDeclaration() :
{}
{
  LOOKAHEAD( ( KT_PUBLIC() | KT_PROTECTED() | KT_PRIVATE() | KT_ABSTRACT() | KT_FINAL()  | KT_STRICTFP() | KT_STATIC() )* KT_CLASS() )
  NestedClassDeclaration()
|
  LOOKAHEAD( ( KT_PUBLIC() | KT_PROTECTED() | KT_PRIVATE() | KT_ABSTRACT() | KT_FINAL()  | KT_STRICTFP() | KT_STATIC() )* KT_INTERFACE() )
  NestedInterfaceDeclaration()
|
  LOOKAHEAD( MethodDeclarationLookahead() )
  MethodDeclaration()
|
  FieldDeclaration()
}

void FieldDeclaration() :
{}
{
  ( KT_PUBLIC() | KT_PROTECTED() | KT_PRIVATE() | KT_STATIC() | KT_FINAL() | KT_TRANSIENT() | KT_VOLATILE() )* #Modifiers(true)
  Type() VariableDeclaratorList() ST_SEMICOLON()
}

void VariableDeclaratorList() :
{}
{
  VariableDeclarator() ( ST_COMMA() VariableDeclarator() )*
}

void VariableDeclarator() :
{}
{
  VariableDeclaratorId() [ OT_ASSIGN() VariableInitializer() ]
}

void VariableDeclaratorId() :
{}
{
  RT_IDENTIFIER() ( ST_LBRACKET() ST_RBRACKET() )*
}

void VariableInitializer() :
{}
{
  ArrayInitializer()
|
  Expression()
}

void ArrayInitializer() :
{}
{
  ST_LBRACE() [ VariableInitializer() ( LOOKAHEAD(2) ST_COMMA() VariableInitializer() )* ] [ ST_COMMA() ] ST_RBRACE()
}

void MethodDeclaration() :
{}
{
  (   KT_PUBLIC() | KT_PROTECTED() | KT_PRIVATE() 
    | KT_STATIC() | KT_ABSTRACT() | KT_FINAL() 
    | KT_NATIVE() | KT_SYNCHRONIZED() | KT_STRICTFP() )* #Modifiers(true)
  ResultType() MethodDeclarator() [ KT_THROWS() NameList() ]
  ( Block() | ST_SEMICOLON() )
}

void MethodDeclarator() :
{}
{
  RT_IDENTIFIER() FormalParameters() ( ST_LBRACKET() ST_RBRACKET() )*
}

void FormalParameters() :
{}
{
  ST_LPAREN() [ FormalParameter() ( ST_COMMA() FormalParameter() )* ] ST_RPAREN()
}

void FormalParameter() :
{}
{
  [ KT_FINAL() ] Type() VariableDeclaratorId()
}

void ConstructorDeclaration() :
{}
{
  [ KT_PUBLIC() | KT_PROTECTED() | KT_PRIVATE() ] #Modifiers(true)
  UnmodifiedConstructorDeclaration()
}

void UnmodifiedConstructorDeclaration() :
{}
{
  RT_IDENTIFIER() FormalParameters() [ KT_THROWS() NameList() ]
  ConstructorBody()
}

void ConstructorBody() :
{}
{
  ST_LBRACE()
  [ LOOKAHEAD(ExplicitConstructorInvocation()) ExplicitConstructorInvocation() ]
  ( BlockStatement() )*
  ST_RBRACE()
}

void ExplicitConstructorInvocation() :
{}
{
  LOOKAHEAD(KT_THIS() Arguments() ST_SEMICOLON())
  KT_THIS() Arguments() ST_SEMICOLON()
|
  [ LOOKAHEAD(2) PrimaryExpression() ST_DOT() ] KT_SUPER() Arguments() ST_SEMICOLON()
}

void Initializer() :
{}
{
  [ KT_STATIC() ] Block()
}


/*
  * Type, name and expression syntax follows.
  */

void Type() :
{}
{
  ( PrimitiveType() | Name() ) ( ST_LBRACKET() ST_RBRACKET() )*
}

void PrimitiveType() :
{}
{
  KT_BOOLEAN()
|
  KT_CHAR()
|
  KT_BYTE()
|
  KT_SHORT()
|
  KT_INT()
|
  KT_LONG()
|
  KT_FLOAT()
|
  KT_DOUBLE()
}

void ResultType() :
{}
{
  KT_VOID()
|
  Type()
}

void Name() :
/*
  * A lookahead of 2 is required below since "Name" can be followed
  * by a ".*" when used in the context of an "ImportDeclaration".
  */
{}
{
  RT_IDENTIFIER()
  ( LOOKAHEAD(2) ST_DOT() RT_IDENTIFIER()
  )*
}

void NameList() :
{}
{
  Name()
  ( ST_COMMA() Name()
  )*
}


/*
  * Expression syntax follows.
  */

void Expression() :
/*
  * This expansion has been written this way instead of:
  * Assignment() | ConditionalExpression()
  * for performance reasons.
  * However, it is a weakening of the grammar for it allows the LHS of
  * assignments to be any conditional expression whereas it can only be
  * a primary expression. Consider adding a semantic predicate to work
  * around this.
  */
{}
{
  ConditionalExpression()
  [ 
  AssignmentOperator() Expression()
  ]
}

void AssignmentOperator() :
{}
{
  OT_ASSIGN() 
| OT_STARASSIGN() 
| OT_SLASHASSIGN() 
| OT_REMASSIGN() 
| OT_PLUSASSIGN() 
| OT_MINUSASSIGN()
| OT_LSHIFTASSIGN()
| OT_RSIGNEDSHIFTASSIGN()
| OT_RUNSIGNEDSHIFTASSIGN()
| OT_ANDASSIGN()
| OT_XORASSIGN()
| OT_ORASSIGN()
}

void ConditionalExpression() :
{}
{
  ConditionalOrExpression() [ OT_HOOK() Expression() OT_COLON() ConditionalExpression() ]
}

void ConditionalOrExpression() :
{}
{
  ConditionalAndExpression() ( OT_SC_OR() ConditionalAndExpression() )*
}

void ConditionalAndExpression() :
{}
{
  InclusiveOrExpression() ( OT_SC_AND() InclusiveOrExpression() )*
}

void InclusiveOrExpression() :
{}
{
  ExclusiveOrExpression() ( OT_BIT_OR() ExclusiveOrExpression() )*
}

void ExclusiveOrExpression() :
{}
{
  AndExpression() ( OT_XOR() AndExpression() )*
}

void AndExpression() :
{}
{
  EqualityExpression() ( OT_BIT_AND() EqualityExpression() )*
}

void EqualityExpression() :
{}
{
  InstanceOfExpression() ( ( OT_EQ() | OT_NE() ) InstanceOfExpression() )*
}

void InstanceOfExpression() :
{}
{
  RelationalExpression() [ KT_INSTANCEOF() Type() ]
}

void RelationalExpression() :
{}
{
  ShiftExpression() ( ( OT_LT() | OT_GT() | OT_LE() | OT_GE() ) ShiftExpression() )*
}

void ShiftExpression() :
{}
{
  AdditiveExpression() ( ( OT_LSHIFT() | OT_RSIGNEDSHIFT() | OT_RUNSIGNEDSHIFT() ) AdditiveExpression() )*
}

void AdditiveExpression() :
{}
{
  MultiplicativeExpression() ( ( OT_PLUS() | OT_MINUS() ) MultiplicativeExpression() )*
}

void MultiplicativeExpression() :
{}
{
  UnaryExpression() ( ( OT_STAR() | OT_SLASH() | OT_REM() ) UnaryExpression() )*
}

void UnaryExpression() :
{}
{
  ( OT_PLUS() | OT_MINUS() ) UnaryExpression()
|
  PreIncrementExpression()
|
  PreDecrementExpression()
|
  UnaryExpressionNotPlusMinus()
}

void PreIncrementExpression() :
{}
{
  OT_INCR() PrimaryExpression()
}

void PreDecrementExpression() :
{}
{
  OT_DECR() PrimaryExpression()
}

void UnaryExpressionNotPlusMinus() :
{}
{
  ( OT_TILDE() | OT_BANG() ) UnaryExpression()
|
  LOOKAHEAD( CastLookahead() )
  CastExpression()
|
  PostfixExpression()
}

// This production is to determine lookahead only. The LOOKAHEAD specifications
// below are not used, but they are there just to indicate that we know about
// this.
void CastLookahead() :
{}
{
  LOOKAHEAD(2)
  ST_LPAREN() PrimitiveType()
|
  LOOKAHEAD(ST_LPAREN() Name() ST_LBRACKET())
  ST_LPAREN() Name() ST_LBRACKET() ST_RBRACKET()
|
  ST_LPAREN() Name() ST_RPAREN() ( OT_TILDE() | OT_BANG() | ST_LPAREN() | RT_IDENTIFIER() | KT_THIS() | KT_SUPER() | KT_NEW() | Literal() )
}

void PostfixExpression() :
{}
{
  PrimaryExpression() [ OT_INCR() | OT_DECR() ]
}

void CastExpression() :
{}
{
  LOOKAHEAD(ST_LPAREN() PrimitiveType())
  ST_LPAREN() Type() ST_RPAREN() UnaryExpression()
|
// removed a LOOKAHEAD which was not technically needed DW, 7/99
  ST_LPAREN() Type() ST_RPAREN() UnaryExpressionNotPlusMinus()
}

void PrimaryExpression() :
{}
{
  PrimaryPrefix() ( LOOKAHEAD(2) PrimarySuffix() )*
}

void PrimaryPrefix() :
{}
{
  Literal()
|
  KT_THIS()
|
  KT_SUPER() ST_DOT() RT_IDENTIFIER()
|
  ST_LPAREN() Expression() ST_RPAREN()
|
  AllocationExpression()
|
  LOOKAHEAD( ResultType() ST_DOT() KT_CLASS() )
  ResultType() ST_DOT() KT_CLASS()
|
  Name()
}

void PrimarySuffix() :
{}
{
  LOOKAHEAD(2)
  ST_DOT() KT_THIS()
|
  LOOKAHEAD(2)
  ST_DOT() AllocationExpression()
|
  ST_LBRACKET() Expression() ST_RBRACKET()
|
  ST_DOT() RT_IDENTIFIER()
|
  Arguments()
}

void Literal() :
{}
{
  RT_INTEGER_LITERAL()
|
  RT_FLOATING_POINT_LITERAL()
|
  RT_CHARACTER_LITERAL()
|
  RT_STRING_LITERAL()
|
  BooleanLiteral()
|
  NullLiteral()
}

void BooleanLiteral() :
{}
{
  KT_TRUE()
|
  KT_FALSE()
}

void NullLiteral() :
{}
{
  KT_NULL()
}

void Arguments() :
{}
{
  ST_LPAREN() [ ArgumentList() ] ST_RPAREN()
}

void ArgumentList() :
{}
{
  Expression() ( ST_COMMA() Expression() )*
}

void AllocationExpression() :
{}
{
  LOOKAHEAD(2)
  KT_NEW() PrimitiveType() ArrayDimsAndInits()
|
  KT_NEW() Name()
  (
  ArrayDimsAndInits()
  |
  Arguments() [ ClassBody() ]
  )
}

/*
  * The second LOOKAHEAD specification below is to parse to PrimarySuffix
  * if there is an expression between the "[...]".
  */
void ArrayDimsAndInits() :
{}
{
  LOOKAHEAD(2)
  ( LOOKAHEAD(2) ST_LBRACKET() Expression() ST_RBRACKET() )+ ( LOOKAHEAD(2) ST_LBRACKET() ST_RBRACKET() )*
|
  ( ST_LBRACKET() ST_RBRACKET() )+ ArrayInitializer()
}


/*
  * Statement syntax follows.
  */

void Statement() :
{}
{
  LOOKAHEAD(2)
  LabeledStatement()
|
  Block()
|
  EmptyStatement()
|
  StatementExpression()  ST_SEMICOLON()
|
  SwitchStatement()
|
  IfStatement()
|
  WhileStatement()
|
  DoStatement()
|
  ForStatement()
|
  BreakStatement()
|
  ContinueStatement()
|
  ReturnStatement()
|
  ThrowStatement()
|
  SynchronizedStatement()
|
  TryStatement()
}

void LabeledStatement() :
{}
{
  RT_IDENTIFIER() OT_COLON() Statement()
}

void Block() :
{}
{
  ST_LBRACE() ( BlockStatement() )* ST_RBRACE()
}

void BlockStatement() :
{}
{
  LOOKAHEAD([ KT_FINAL() ] Type() RT_IDENTIFIER() )
  LocalVariableDeclaration() ST_SEMICOLON()
|
  Statement()
|
  UnmodifiedClassDeclaration()
|
// added this choice point to handle inner interfaces. DW, 7/99
  UnmodifiedInterfaceDeclaration()
}

void LocalVariableDeclaration() :
{}
{
  [ KT_FINAL() ] #Modifiers(true)
  Type() VariableDeclarator() ( ST_COMMA() VariableDeclarator() )*
}

void EmptyStatement() :
{}
{
  ST_SEMICOLON()
}

void StatementExpression() :
/*
  * The last expansion of this production accepts more than the legal
  * Java expansions for StatementExpression. This expansion does not
  * use PostfixExpression for performance reasons.
  */
{}
{
  PreIncrementExpression()
|
  PreDecrementExpression()
|
  PrimaryExpression()
  [
  OT_INCR()
  |
  OT_DECR()
  |
  AssignmentOperator() Expression()
  ]
}

void SwitchStatement() :
{}
{
  KT_SWITCH() ST_LPAREN() Expression() ST_RPAREN() ST_LBRACE()
  ( SwitchLabel() ( BlockStatement() )* )*
  ST_RBRACE()
}

void SwitchLabel() :
{}
{
  KT_CASE() Expression() OT_COLON()
|
  KT_DEFAULT() OT_COLON()
}

void IfStatement() :
/*
  * The disambiguating algorithm of JavaOneDotTwo automatically binds dangling
  * else's to the innermost if statement. The LOOKAHEAD specification
  * is to tell JavaOneDotTwo that we know what we are doing.
  */
{}
{
  KT_IF() ST_LPAREN() Expression() ST_RPAREN() Statement() [ LOOKAHEAD(1) KT_ELSE() Statement() ]
}

void WhileStatement() :
{}
{
  KT_WHILE() ST_LPAREN() Expression() ST_RPAREN() Statement()
}

void DoStatement() :
{}
{
  KT_DO() Statement() KT_WHILE() ST_LPAREN() Expression() ST_RPAREN() ST_SEMICOLON()
}

void ForStatement() :
{}
{
  KT_FOR() ST_LPAREN()
  
  ( [ ForInit() ] ST_SEMICOLON() [ Expression() ] ST_SEMICOLON() [ ForUpdate() ] ) #ForControl(true)
  
  ST_RPAREN() Statement()
}

void ForInit() :
{}
{
  LOOKAHEAD( [ KT_FINAL() ] Type() RT_IDENTIFIER() )
  LocalVariableDeclaration()
|
  StatementExpressionList()
}

void StatementExpressionList() :
{}
{
  StatementExpression() ( ST_COMMA() StatementExpression() )*
}

void ForUpdate() :
{}
{
  StatementExpressionList()
}

void BreakStatement() :
{}
{
  KT_BREAK() [ RT_IDENTIFIER() ] ST_SEMICOLON()
}

void ContinueStatement() :
{}
{
  KT_CONTINUE() [ RT_IDENTIFIER() ] ST_SEMICOLON()
}

void ReturnStatement() :
{}
{
  KT_RETURN() [ Expression() ] ST_SEMICOLON()
}

void ThrowStatement() :
{}
{
  KT_THROW() Expression() ST_SEMICOLON()
}

void SynchronizedStatement() :
{}
{
  KT_SYNCHRONIZED() ST_LPAREN() Expression() ST_RPAREN() Block()
}

void TryStatement() :
/*
  * Semantic check required here to make sure that at least one
  * finally/catch is present.
  */
{}
{
  KT_TRY() Block()
  ( CatchBlock() )* 
  [ FinallyBlock() ]
}

void CatchBlock() :
/* catch block */
{}
{
  KT_CATCH() ST_LPAREN() FormalParameter() ST_RPAREN() Block()
}

void FinallyBlock() :
/* finally block */
{}
{
  KT_FINALLY() Block()
}


//--------------------------------------------------------------------//
// TOKENS //
//--------------------------------------------------------------------//

/* REGULAR EXPRESSION TOKENS */

void RT_CHARACTER_LITERAL()
#Token :
{ Token t; }
{ t = <CHARACTER_LITERAL> { jjtThis.setToken(t); jjtThis.tagId = jjtThis.CHARACTER_LITERAL; } }

void RT_FLOATING_POINT_LITERAL()
#Token :
{ Token t; }
{ t = <FLOATING_POINT_LITERAL> { jjtThis.setToken(t); jjtThis.tagId = jjtThis.FLOATING_POINT_LITERAL; } }

void RT_IDENTIFIER()
#Keyword :
{ Token t; }
{ t = <IDENTIFIER> { jjtThis.setToken(t); jjtThis.tagId = jjtThis.IDENTIFIER; } }

void RT_INTEGER_LITERAL()
#Token :
{ Token t; }
{ t = <INTEGER_LITERAL> { jjtThis.setToken(t); jjtThis.tagId = jjtThis.INTEGER_LITERAL; } }

void RT_STRING_LITERAL()
#Token :
{ Token t; }
{ t = <STRING_LITERAL> { jjtThis.setToken(t); jjtThis.tagId = jjtThis.STRING_LITERAL; } }



/* CONSTANT TOKENS */

/* KEYWORDS */

void KT_ABSTRACT()
#Keyword :
{ Token t; }
{ t = <ABSTRACT> {jjtThis.setToken(t); jjtThis.tagId = jjtThis.ABSTRACT; } }

void KT_BOOLEAN()
#Keyword :
{ Token t; }
{ t = <BOOLEAN> {jjtThis.setToken(t); jjtThis.tagId = jjtThis.BOOLEAN; } }

void KT_BREAK()
#Keyword :
{ Token t; }
{ t = <BREAK> {jjtThis.setToken(t); jjtThis.tagId = jjtThis.BREAK; } }

void KT_BYTE()
#Keyword :
{ Token t; }
{ t = <BYTE> {jjtThis.setToken(t); jjtThis.tagId = jjtThis.BYTE; } }

void KT_CASE()
#Keyword :
{ Token t; }
{ t = <CASE> {jjtThis.setToken(t); jjtThis.tagId = jjtThis.CASE; } }

void KT_CATCH()
#Keyword :
{ Token t; }
{ t = <CATCH> {jjtThis.setToken(t); jjtThis.tagId = jjtThis.CATCH; } }

void KT_CHAR()
#Keyword :
{ Token t; }
{ t = <CHAR> {jjtThis.setToken(t); jjtThis.tagId = jjtThis.CHAR; } }

void KT_CLASS()
#Keyword :
{ Token t; }
{ t = <CLASS> {jjtThis.setToken(t); jjtThis.tagId = jjtThis.CLASS; } }

void KT_CONST()
#Keyword :
{ Token t; }
{ t = <CONST> {jjtThis.setToken(t); jjtThis.tagId = jjtThis.CONST; } }
 // ???
void KT_CONTINUE()
#Keyword :
{ Token t; }
{ t = <CONTINUE> {jjtThis.setToken(t); jjtThis.tagId = jjtThis.CONTINUE; } }

void KT_DEFAULT()
#Keyword :
{ Token t; }
{ t = <_DEFAULT> {jjtThis.setToken(t); jjtThis.tagId = jjtThis.DEFAULT; } }
 // !!! stet !!!
void KT_DO()
#Keyword :
{ Token t; }
{ t = <DO> {jjtThis.setToken(t); jjtThis.tagId = jjtThis.DO; } }

void KT_DOUBLE()
#Keyword :
{ Token t; }
{ t = <DOUBLE> {jjtThis.setToken(t); jjtThis.tagId = jjtThis.DOUBLE; } }

void KT_ELSE()
#Keyword :
{ Token t; }
{ t = <ELSE> {jjtThis.setToken(t); jjtThis.tagId = jjtThis.ELSE; } }

void KT_EXTENDS()
#Keyword :
{ Token t; }
{ t = <EXTENDS> {jjtThis.setToken(t); jjtThis.tagId = jjtThis.EXTENDS; } }

void KT_FALSE()
#Keyword :
{ Token t; }
{ t = <FALSE> {jjtThis.setToken(t); jjtThis.tagId = jjtThis.FALSE; } }

void KT_FINAL()
#Keyword :
{ Token t; }
{ t = <FINAL> {jjtThis.setToken(t); jjtThis.tagId = jjtThis.FINAL; } }

void KT_FINALLY()
#Keyword :
{ Token t; }
{ t = <FINALLY> {jjtThis.setToken(t); jjtThis.tagId = jjtThis.FINALLY; } }

void KT_FLOAT()
#Keyword :
{ Token t; }
{ t = <FLOAT> {jjtThis.setToken(t); jjtThis.tagId = jjtThis.FLOAT; } }

void KT_FOR()
#Keyword :
{ Token t; }
{ t = <FOR> {jjtThis.setToken(t); jjtThis.tagId = jjtThis.FOR; } }

void KT_GOTO()
#Keyword :
{ Token t; }
{ t = <GOTO> {jjtThis.setToken(t); jjtThis.tagId = jjtThis.GOTO; } }
 // ???
void KT_IF()
#Keyword :
{ Token t; }
{ t = <IF> {jjtThis.setToken(t); jjtThis.tagId = jjtThis.IF; } }

void KT_IMPLEMENTS()
#Keyword :
{ Token t; }
{ t = <IMPLEMENTS> {jjtThis.setToken(t); jjtThis.tagId = jjtThis.IMPLEMENTS; } }

void KT_IMPORT()
#Keyword :
{ Token t; }
{ t = <IMPORT> {jjtThis.setToken(t); jjtThis.tagId = jjtThis.IMPORT; } }

void KT_INSTANCEOF()
#Keyword :
{ Token t; }
{ t = <INSTANCEOF> {jjtThis.setToken(t); jjtThis.tagId = jjtThis.INSTANCEOF; } }

void KT_INT()
#Keyword :
{ Token t; }
{ t = <INT> {jjtThis.setToken(t); jjtThis.tagId = jjtThis.INT; } }

void KT_INTERFACE()
#Keyword :
{ Token t; }
{ t = <INTERFACE> {jjtThis.setToken(t); jjtThis.tagId = jjtThis.INTERFACE; } }

void KT_LONG()
#Keyword :
{ Token t; }
{ t = <LONG> {jjtThis.setToken(t); jjtThis.tagId = jjtThis.LONG; } }

void KT_NATIVE()
#Keyword :
{ Token t; }
{ t = <NATIVE> {jjtThis.setToken(t); jjtThis.tagId = jjtThis.NATIVE; } }

void KT_NEW()
#Keyword :
{ Token t; }
{ t = <NEW> {jjtThis.setToken(t); jjtThis.tagId = jjtThis.NEW; } }

void KT_NULL()
#Keyword :
{ Token t; }
{ t = <NULL> {jjtThis.setToken(t); jjtThis.tagId = jjtThis.NULL; } }

void KT_PACKAGE()
#Keyword :
{ Token t; }
{ t = <PACKAGE> {jjtThis.setToken(t); jjtThis.tagId = jjtThis.PACKAGE; } }

void KT_PRIVATE()
#Keyword :
{ Token t; }
{ t = <PRIVATE> {jjtThis.setToken(t); jjtThis.tagId = jjtThis.PRIVATE; } }

void KT_PROTECTED()
#Keyword :
{ Token t; }
{ t = <PROTECTED> {jjtThis.setToken(t); jjtThis.tagId = jjtThis.PROTECTED; } }

void KT_PUBLIC()
#Keyword :
{ Token t; }
{ t = <PUBLIC> {jjtThis.setToken(t); jjtThis.tagId = jjtThis.PUBLIC; } }

void KT_RETURN()
#Keyword :
{ Token t; }
{ t = <RETURN> {jjtThis.setToken(t); jjtThis.tagId = jjtThis.RETURN; } }

void KT_SHORT()
#Keyword :
{ Token t; }
{ t = <SHORT> {jjtThis.setToken(t); jjtThis.tagId = jjtThis.SHORT; } }

void KT_STATIC()
#Keyword :
{ Token t; }
{ t = <STATIC> {jjtThis.setToken(t); jjtThis.tagId = jjtThis.STATIC; } }

void KT_STRICTFP()
#Keyword :
{ Token t; }
{ t = <STRICTFP> {jjtThis.setToken(t); jjtThis.tagId = jjtThis.STRICTFP; } }

void KT_SUPER()
#Keyword :
{ Token t; }
{ t = <SUPER> {jjtThis.setToken(t); jjtThis.tagId = jjtThis.SUPER; } }

void KT_SWITCH()
#Keyword :
{ Token t; }
{ t = <SWITCH> {jjtThis.setToken(t); jjtThis.tagId = jjtThis.SWITCH; } }

void KT_SYNCHRONIZED()
#Keyword :
{ Token t; }
{ t = <SYNCHRONIZED> {jjtThis.setToken(t); jjtThis.tagId = jjtThis.SYNCHRONIZED; } }

void KT_THIS()
#Keyword :
{ Token t; }
{ t = <THIS> {jjtThis.setToken(t); jjtThis.tagId = jjtThis.THIS; } }

void KT_THROW()
#Keyword :
{ Token t; }
{ t = <THROW> {jjtThis.setToken(t); jjtThis.tagId = jjtThis.THROW; } }

void KT_THROWS()
#Keyword :
{ Token t; }
{ t = <THROWS> {jjtThis.setToken(t); jjtThis.tagId = jjtThis.THROWS; } }

void KT_TRANSIENT()
#Keyword :
{ Token t; }
{ t = <TRANSIENT> {jjtThis.setToken(t); jjtThis.tagId = jjtThis.TRANSIENT; } }

void KT_TRUE()
#Keyword :
{ Token t; }
{ t = <TRUE> {jjtThis.setToken(t); jjtThis.tagId = jjtThis.TRUE; } }

void KT_TRY()
#Keyword :
{ Token t; }
{ t = <TRY> {jjtThis.setToken(t); jjtThis.tagId = jjtThis.TRY; } }

void KT_VOID()
#Keyword :
{ Token t; }
{ t = <VOID> {jjtThis.setToken(t); jjtThis.tagId = jjtThis.VOID; } }

void KT_VOLATILE()
#Keyword :
{ Token t; }
{ t = <VOLATILE> {jjtThis.setToken(t); jjtThis.tagId = jjtThis.VOLATILE; } }

void KT_WHILE()
#Keyword :
{ Token t; }
{ t = <WHILE> {jjtThis.setToken(t); jjtThis.tagId = jjtThis.WHILE; } }



/* SEPARATORS */

void ST_LPAREN() #Token :
{ Token t; }
{ t = <LPAREN> {jjtThis.setToken(t); jjtThis.tagId = jjtThis.LPAREN; } }

void ST_RPAREN() #Token :
{ Token t; }
{ t = <RPAREN> {jjtThis.setToken(t); jjtThis.tagId = jjtThis.RPAREN; } }

void ST_LBRACE() #Token :
{ Token t; }
{ t = <LBRACE> {jjtThis.setToken(t); jjtThis.tagId = jjtThis.LBRACE; } }

void ST_RBRACE() #Token :
{ Token t; }
{ t = <RBRACE> {jjtThis.setToken(t); jjtThis.tagId = jjtThis.RBRACE; } }

void ST_LBRACKET() #Token :
{ Token t; }
{ t = <LBRACKET> {jjtThis.setToken(t); jjtThis.tagId = jjtThis.LBRACKET; } }

void ST_RBRACKET() #Token :
{ Token t; }
{ t = <RBRACKET> {jjtThis.setToken(t); jjtThis.tagId = jjtThis.RBRACKET; } }

void ST_SEMICOLON() #Token :
{ Token t; }
{ t = <SEMICOLON> {jjtThis.setToken(t); jjtThis.tagId = jjtThis.SEMICOLON; } }

void ST_COMMA() #Token :
{ Token t; }
{ t = <COMMA> {jjtThis.setToken(t); jjtThis.tagId = jjtThis.COMMA; } }

void ST_DOT() #Token :
{ Token t; }
{ t = <DOT> {jjtThis.setToken(t); jjtThis.tagId = jjtThis.DOT; } }

void ST_EOF() #Token :
{ Token t; }
{ t = <EOF> {t.image = ""; jjtThis.setToken(t); jjtThis.tagId = jjtThis.EOF; } }



/* OPERATORS */

void OT_ASSIGN() #Token :
{ Token t; }
{ t = <ASSIGN> {jjtThis.setToken(t); jjtThis.tagId = jjtThis.ASSIGN; } }

void OT_GT() #Token :
{ Token t; }
{ t = <GT> {jjtThis.setToken(t); jjtThis.tagId = jjtThis.GT; } }

void OT_LT() #Token :
{ Token t; }
{ t = <LT> {jjtThis.setToken(t); jjtThis.tagId = jjtThis.LT; } }

void OT_BANG() #Token :
{ Token t; }
{ t = <BANG> {jjtThis.setToken(t); jjtThis.tagId = jjtThis.BANG; } }

void OT_TILDE() #Token :
{ Token t; }
{ t = <TILDE> {jjtThis.setToken(t); jjtThis.tagId = jjtThis.TILDE; } }

void OT_HOOK() #Token :
{ Token t; }
{ t = <HOOK> {jjtThis.setToken(t); jjtThis.tagId = jjtThis.HOOK; } }

void OT_COLON() #Token :
{ Token t; }
{ t = <COLON> {jjtThis.setToken(t); jjtThis.tagId = jjtThis.COLON; } }

void OT_EQ() #Token :
{ Token t; }
{ t = <EQ> {jjtThis.setToken(t); jjtThis.tagId = jjtThis.EQ; } }

void OT_LE() #Token :
{ Token t; }
{ t = <LE> {jjtThis.setToken(t); jjtThis.tagId = jjtThis.LE; } }

void OT_GE() #Token :
{ Token t; }
{ t = <GE> {jjtThis.setToken(t); jjtThis.tagId = jjtThis.GE; } }

void OT_NE() #Token :
{ Token t; }
{ t = <NE> {jjtThis.setToken(t); jjtThis.tagId = jjtThis.NE; } }

void OT_SC_OR() #Token :
{ Token t; }
{ t = <SC_OR> {jjtThis.setToken(t); jjtThis.tagId = jjtThis.SC_OR; } }

void OT_SC_AND() #Token :
{ Token t; }
{ t = <SC_AND> {jjtThis.setToken(t); jjtThis.tagId = jjtThis.SC_AND; } }

void OT_INCR() #Token :
{ Token t; }
{ t = <INCR> {jjtThis.setToken(t); jjtThis.tagId = jjtThis.INCR; } }

void OT_DECR() #Token :
{ Token t; }
{ t = <DECR> {jjtThis.setToken(t); jjtThis.tagId = jjtThis.DECR; } }

void OT_PLUS() #Token :
{ Token t; }
{ t = <PLUS> {jjtThis.setToken(t); jjtThis.tagId = jjtThis.PLUS; } }

void OT_MINUS() #Token :
{ Token t; }
{ t = <MINUS> {jjtThis.setToken(t); jjtThis.tagId = jjtThis.MINUS; } }

void OT_STAR() #Token :
{ Token t; }
{ t = <STAR> {jjtThis.setToken(t); jjtThis.tagId = jjtThis.STAR; } }

void OT_SLASH() #Token :
{ Token t; }
{ t = <SLASH> {jjtThis.setToken(t); jjtThis.tagId = jjtThis.SLASH; } }

void OT_BIT_AND() #Token :
{ Token t; }
{ t = <BIT_AND> {jjtThis.setToken(t); jjtThis.tagId = jjtThis.BIT_AND; } }

void OT_BIT_OR() #Token :
{ Token t; }
{ t = <BIT_OR> {jjtThis.setToken(t); jjtThis.tagId = jjtThis.BIT_OR; } }

void OT_XOR() #Token :
{ Token t; }
{ t = <XOR> {jjtThis.setToken(t); jjtThis.tagId = jjtThis.XOR; } }

void OT_REM() #Token :
{ Token t; }
{ t = <REM> {jjtThis.setToken(t); jjtThis.tagId = jjtThis.REM; } }

void OT_LSHIFT() #Token :
{ Token t; }
{ t = <LSHIFT> {jjtThis.setToken(t); jjtThis.tagId = jjtThis.LSHIFT; } }

void OT_RSIGNEDSHIFT() #Token :
{ Token t; }
{ t = <RSIGNEDSHIFT> {jjtThis.setToken(t); jjtThis.tagId = jjtThis.RSIGNEDSHIFT; } }

void OT_RUNSIGNEDSHIFT() #Token :
{ Token t; }
{ t = <RUNSIGNEDSHIFT> {jjtThis.setToken(t); jjtThis.tagId = jjtThis.RUNSIGNEDSHIFT; } }

void OT_PLUSASSIGN() #Token :
{ Token t; }
{ t = <PLUSASSIGN> {jjtThis.setToken(t); jjtThis.tagId = jjtThis.PLUSASSIGN; } }

void OT_MINUSASSIGN() #Token :
{ Token t; }
{ t = <MINUSASSIGN> {jjtThis.setToken(t); jjtThis.tagId = jjtThis.MINUSASSIGN; } }

void OT_STARASSIGN() #Token :
{ Token t; }
{ t = <STARASSIGN> {jjtThis.setToken(t); jjtThis.tagId = jjtThis.STARASSIGN; } }

void OT_SLASHASSIGN() #Token :
{ Token t; }
{ t = <SLASHASSIGN> {jjtThis.setToken(t); jjtThis.tagId = jjtThis.SLASHASSIGN; } }

void OT_ANDASSIGN() #Token :
{ Token t; }
{ t = <ANDASSIGN> {jjtThis.setToken(t); jjtThis.tagId = jjtThis.ANDASSIGN; } }

void OT_ORASSIGN() #Token :
{ Token t; }
{ t = <ORASSIGN> {jjtThis.setToken(t); jjtThis.tagId = jjtThis.ORASSIGN; } }

void OT_XORASSIGN() #Token :
{ Token t; }
{ t = <XORASSIGN> {jjtThis.setToken(t); jjtThis.tagId = jjtThis.XORASSIGN; } }

void OT_REMASSIGN() #Token :
{ Token t; }
{ t = <REMASSIGN> {jjtThis.setToken(t); jjtThis.tagId = jjtThis.REMASSIGN; } }

void OT_LSHIFTASSIGN() #Token :
{ Token t; }
{ t = <LSHIFTASSIGN> {jjtThis.setToken(t); jjtThis.tagId = jjtThis.LSHIFTASSIGN; } }

void OT_RSIGNEDSHIFTASSIGN() #Token :
{ Token t; }
{ t = <RSIGNEDSHIFTASSIGN> {jjtThis.setToken(t); jjtThis.tagId = jjtThis.RSIGNEDSHIFTASSIGN; } }

void OT_RUNSIGNEDSHIFTASSIGN() #Token :
{ Token t; }
{ t = <RUNSIGNEDSHIFTASSIGN> {jjtThis.setToken(t); jjtThis.tagId = jjtThis.RUNSIGNEDSHIFTASSIGN; } }
